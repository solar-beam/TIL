# [git-core-tutorial](https://git-scm.com/docs/gitcore-tutorial)
> 깃 매뉴얼 페이지를 내가 이해하기 쉽게, 이해한대로, 발췌번역 및 부연함  

깃을 RCS(Revision control system)으로 사용한다면 굳이 이 문서를 읽을 필요는 없죠.  
그런 목적이라면 "A Tutorial Introduction to Git"라는 문서도 있어요.  
> RCS란 초창기 VCS(Version Control System)의 하나로서, 
> 다수사용자가 함께 개발하고 프로그램 코드와 문서를 관리할 수 있도록 돕는 UNIX명령어의 집합으로 볼 수 있다.  
> 프로그래머를 위해 만들어졌지만 수정이 잦은 텍스트문서나 설정파일을 관리하는 데도 유용하다.  
> 단일 파일에 대해서만 작업할 수 있고, 브랜치 기능이 제공되긴 하나 대부분 잘 활용하진 않는다.  
> [출처: 위키백과 RCS(https://en.wikipedia.org/wiki/Revision_Control_System)](https://en.wikipedia.org/wiki/Revision_Control_System)
> 고려청자를 요강으로 쓸 사람은 '도자문화이해'까지 수강할 필요는 없다... 
> 이정도로 이해된다.  

깃의 내부를 이해하고 싶은 거라면, 이 문서에서 다룰 저수준의 도구를 이해하는게 분명 도움이 될 거에요.  

코어깃, 깃의 핵, 깃의 내부, 이른바 깃의 `plumbing(배관)` 위로는  
사용자 인터페이스를 담당하는, 이른바 깃의 `porcelain(타일)`이 깔려 있어요.  
변기물을 내리기 위해 누가 화장실 타일을 뜯어내고 배관을 직접 만지던가요.  
그러고 싶은 사람이 있기야 할까요?  
그런데 이런 경우 있지 않나요? 뚫어뻥을 사다가 몇통을 붓고, 펌프질을 해도 
인간존엄의 밑바닥을 확인할뿐 원하는 결과..?는 얻지 못했던 일.  
망치를 들고 타일을 부숴 직접 배관을 확인하고 싶은 마음이 가득했던 일.  

이 문서는 원래, 많은 	`porcelain` 명령어가 쉘스크립트였던 시절에 작성되었죠.  
편의를 위해서 여전히 쉘스크립트 명령어를 예로 들고 있구요.  
(`porcelain`아래로 지나가는 `plumbing`파이프가 어떻게 갖춰져 있는지를 설명하는 데 말이에요.)  
지금이야 `plumbing` 계층 명령어가 쉘스크립트로 구현되어 있지는 않지만,  
그럼에도 `plumbing` 계층의 원리를 이해하는 데는 이 문서가 분명 도움이 될 거에요.  
> NOTE 코어깃 튜토리얼에서 보다 기술적으로 세부적인 내용을 다루는 부분임
> NOTE 표시가 없으면, 번역자가 맘대로 추가한 부분임

## Git저장소 만들기

깃 저장소를 만드는건 쉬워도 너무 쉽다. 이보다 쉬울 순 없다.  
작업트리로 사용할 하위 디렉토리를 찾기만 하면 된다.  
빈 디렉토리를 새로운 프로젝트의 저장소로 사용해도 되고,  
이미 사용중인 작업트리를 깃으로 import할 수도 있다.  
> 깃은 작업공간을 셋으로 구분한다. 원격저장소, (가상의)인덱스, 그리고 작업트리
> 작업트리는 현재 프로그램을 짜고 있는 디렉토리를 말하고, 이중 커밋할 것을 골라(예를들어 설정파일은 제외하고)
> 가상의 인덱스에 등록(staging)하여 최종적으로 원격저장소로 push하는 개념이다.
> [출처: 워크트리와 인덱스(https://backlog.com/git-tutorial/kr/intro/intro1_4.html)](https://backlog.com/git-tutorial/kr/intro/intro1_4.html)


첫번째 예제에서는, 새 저장소를 *from scratch(밑바닥부터)* 만들어볼 것이다.  
*git-tutorial*이라 부르기로 하고, 먼저 그 이름으로 디렉토리를 만들어보자.  
디렉토리로 진입하고, `git init` 명령어로, 시작해보자.  
> 리눅스,맥이라면 상관없겠지만 윈도우라면 기본 cmd나 powershell을 사용하다간  
> 대부분의 문서에서 윈도우 커맨드라인을 고려하지 않으므로(기본이 mac아니면 ubuntu) 
> 깃을 다 배우기도 전에 답답증에 골로갈 수 있으므로, git을 설치할 때 git bash도 함께 설치해서 사용하자.  
> 작업할 폴더로 가서 오른쪽 마우스를 클릭하면 해당 위치에서 git bash를 열 수 있다.  
> 어떤 원리인지는 잘 모르겠지만 cd/ls/mkdir와 같은 리눅스 명령어도 사용할 수 있다.  
> 요새는 윈도우에서 Linux 서브시스템을 사용할 수도 있다던데, 굳이?? 그럴바엔 듀얼부팅을 하겠다.  
> Linux서브시스템은 윈도우 앱스토어에서 다운을 받아야한다(64bit만 지원)

```
$ mkdir git-tutorial
$ cd git-tutorial
$ git init
```

명령어를 입력하면, 쉘에 이렇게 나온다.

```
Initialized empty Git repository in .git/
```  

무슨 뜻이냐 하면, ./git 디렉토리를 새로 만들었고 뭐 별다른거 없이 잘 끝났다는 뜻.  
`ls` 명령어로 디렉토리를 들여다보면 이것저것 많은데,  
굳이 다 볼 필요는 없다.  
- `HEAD`라는 파일이 있을 거다. 안에는 `ref: refs/heads/master`라는 라인이 있는데, ref를 `HEAD`파일과 관련된 `refs/heads/master`를 가리키는 심볼릭링크처럼 쓰겠다는 뜻이다. 사실 아직 `refs/heads/master`는 존재하지도 않는데, 걱정하지 말자. `HEAD`는 현재 작업중인 브랜치의 최신 커밋을 가리키는 포인터인데, 아직 아무 커밋도 없으니까 그게 당연한 거다.  
- `objects`라는 디렉토리도 있을 거다. 깃프로젝트의 모든 objects가 죄다 여기로 올건데, objects를 직접 찾아서 여기까지 올 일은 없을 거다. 그럴만한 이유가 없다. 그런데, 그,런,데, 깃저장소가 실제로 지지고볶는 실제 *data*는 다 objects안에 있다.  
- `refs`라는 디렉토리, objects에 대한 레퍼런스가 여기 모일거다.  
> git reflog치면 커밋이든 브랜치든 헤드든 뭐든 깃 오브젝트를 가리키는 포인터 목록이 뜬다.
> 그게 여기 있는 거.  
> git reset --hard <해시값> 이러면 `HEAD`가 해당 커밋으로 강제로 이동되는데
> 이때 그 이후의 커밋에서 해당커밋까지 부모커밋을 가리키는 링크가 사라지는거지
> 실제로 커밋 오브젝트가 사라지는건 아니다. 해당 오브젝트를 가리키는 ref도 여기에 고이 잘 있다.
> 그래서 git reflog를 이용해 해시값을 찾아 해당 커밋버전으로 이동하는 것도 가능한거다.

`refs`디렉토리에는 각각 `heads`, `tags`라는 이름으로 디렉토리가 또 생길텐데, 
디렉토리 이름과 정확히 같은 일을 한다.
브랜치(*역자주 : 코어깃 튜토리얼에선 깃브랜치를 development라고 부르는데, 헷갈리니까 그냥 브랜치라고 적는다)를 가리키는 `heads`, 
그리고 깃저장소의 특정 버전을 가리키는 `tags`가 각각의 폴더로 모일거다.   

노트1: 기본브랜치를 가리키는 `master` head는, 깃저장소 만들고 브랜치가 존재하지도 않을때도 ./git/HEAD파일에 이-미 들어가 있다. 기본적으로, HEAD링크는 지금 작업중인 브랜치를 가리키는 건데, master브랜치에서 작업을 시작한다고 가정하는 거다.
그런데 이건 관습일뿐이라서, 브랜치 이름은 원하는대로 아무렇게나 지으면 된다. 사실 master 브랜치가 없어도 무방하다. 

> 깃저장소를 만들고 작업을 하면, `refs`디렉토리에 41byte 파일이 계속 생기는걸 볼 수 있다.
> 이건 이른바 *object name*, 160bit SHA-1 해시로 만들어진 object식별자인데,
> `refs` 디렉토리 파일에 16진수 레퍼런스 형태로 저장된다.

이로써 첫 깃저장소를 만들어보았다. 






























